1.2　数据类型

(1) 基本数据类型(常用)
	  名称	        占用空间      数据范围
	int(整型)		   4	    -2^31~2^31-1
    char(字符型)	   1		  –128～127
    short(短整型) 	   2	    -2^15~2^15-1
    long long(长整型)  8	    -2^63~2^63-1
    bool(布尔型)	   1		 true或false
	float(单精度浮点)  4		3.4E +/- 38 
							    (7位有效数字)
	double(双精度浮点) 8	    1.7E +/- 308 
							    (15位有效数字)
	
	关于前缀unsigned：基本用不到，有兴趣的自己查资料吧。

(2) 变量与常量
	1.定义变量："变量类型 标识符"，如"int i;"定义了一个名字为i的整型变量。
	    注意，此时i并未初始化，所以i的值是不确定的。
	2.定义常量："const 变量类型 标识符=初始值"，如：const int N=90;
	3.合法的标识符：
		标识符不能和关键字(在IDE中会变色的词语)相同。
		标识符只能包括字母、数字和下划线"_"，并且开头只能是字母或下划线。
		标识符必须先定义后使用。
		在同一作用域内，标识符不能重复定义。
		C++区分大小写。所以A和a是两个不同的标识符。

(3) 数组
	1.定义一个一维数组：int a[10];这个数组一共10个元素，下标分别为0～9。访问某个元素时，直接用a加方括号，如a[5]。
	2.定义一个二维数组：int b[5][3];这个数组一共5×3＝15个元素，分别是b[0][0]、b[0][1]、b[0][2]、b[1][0]……b[4][2]。
	访问某个元素时要用两个方括号，如b[2][1]。
	多维数组的定义和使用方法与此类似。
	3.数组名和元素的寻址：以上面的a、b为例
		数组名是一个指针，指向整个数组第一个元素所在的地址。
			如a就是&a[0]、b就是&b[0][0]。
		在内存中，数组中每个元素都是紧挨着的，所以可以直接进行指针的运算。
			如a+3就是&a[3]，**(b+1)就是b[1][0]，*(*(b+3)+2)就是b[3][2]。
		在竞赛中要尽可能回避这些功能。
	4.字符串：
		字符串实际上是char的数组。
		字符串最后一位必须是'\0'，否则会在进行输出、使用字符串函数时发生意外。
		数组，包括字符串，不可以整体地赋值和比较。
			如果需要，应使用memcpy和memcmp(字符串是strcpy和strcmp)。
	5.C++中数组的下标只能从0开始(当然可以闲置不用)，并且int a[10]中a的最后一个元素是a[9]，不是a[10]！
	6.C++不检查数组下标是否越界！如果下标越界，程序很有可能会崩溃！

(4) 指针
1.	取地址运算符和取值运算符：
	取地址运算符"&"：返回变量所在的地址。一般用于变量。(而数组名本身就是指针，无需"&")
	取值运算符"*"：返回地址对应的值，或用于改变指针所指内存空间的值。只能用于指针。
2.	指针的意义：保存另一个变量的内存地址。
3.	定义指针：int *p;
定义多个指针时，每个字母的前面都要有"*"。
注意，如果p没有被初始化，它就会指向一个未知的内存空间，而错误地操作内存会导致程序崩溃！
4.	指针使用实例：
	为了不在竞赛中把自己搞晕，请回避指针，对其敬而远之。如果感兴趣请自行查阅资料。

(5) 引用
	通俗地讲，引用是某个变量的别名。下面定义了一个叫p的引用，它实际上是f[0][2]。无论是改变p的值，还是改变f[0][2]的值，结果都是一样的。
	int &p = f[0][2];
	使用引用的好处是，在函数的形参中定义引用类型，可以直接修改变量的值，而不用考虑"&"和"*"运算符。像上面一行代码一样，如果频繁调用f[0][2]，也可以用引用节省篇幅，提高代码可读性。
	引用与指针不同。引用被创建的同时也必须被初始化，并且必须与合法的存储单元关联。一旦引用被初始化，就不能改变引用的关系。而指针可以不立刻初始化，也可以改变所指向的内存空间。

(6) 结构体
	结构体用struct定义。例如下面代码定义了一个叫pack的结构体，它有两个成员，一个叫value，另一个叫weight。
		struct pack
		{
			int value, weight;
		};//注意分号
	变量可以定义成上面的pack类型：pack p;不必写成struct pack p;
	访问pack的成员时，用"."运算符：p.value;
	C++中结构体可以像类一样建立自己的构造函数、成员函数，也可以重载运算符。
	对于pack这个结构体，它的内部不允许再有pack类型的成员，但是可以有pack类型的指针。
